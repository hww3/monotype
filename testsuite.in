
test_true(objectp(Monotype));
test_true(programp(Monotype.Generator));

test_true(objectp(Monotype.load_stopbar(combine_path(getcwd(), "test/wedges", "s5"))));
test_true(objectp(Monotype.load_matcase(combine_path(getcwd(), "test/matcases", "garamond"))))

test_do(add_constant("dictdir", combine_path(getcwd(), "test/dicts")));
test_do(add_constant("test_mca", Monotype.load_matcase(combine_path(getcwd(), "test/matcases", "garamond"))));
test_do(add_constant("test_stopbar", Monotype.load_stopbar(combine_path(getcwd(), "test/wedges", "s5"))));

test_do(add_constant("settings", ([
     "allow_lowercase_smallcaps": 0,
     "allow_punctuation_substitution": 0,
     "enable_combined_space": 1,
     "hyphenate": 1,
     "hyphenate_no_hyphen": 0,
     "jobname": "",
     "justification": 1,
     "lang": "en_US",
     "linelengthp": 10.0,
     "min_big": 3,
     "min_little": 8,
     "mould": 12,
     "page_length": 42,
     "pointsystem": 12.0,
     "setwidth": 12.0,
     "unit_adding": 0,
     "unit_shift": 0,
     "unnatural_word_breaks": 0,
     "dict_dir": dictdir,
     "matcase": test_mca,
     "stopbar": test_stopbar,
   ])))
   
test_any([[
  // <qo> should give appropriately sized spaces.
  object g = Monotype.Generator(settings);
  g->parse("Mary had a little lamb<qo>\n");
  g->generate_ribbon();
  werror("large: %O small: %O\n", g->lines[0]->big, g->lines[0]->little);
  return ((g->lines[0]->little == 8) && (g->lines[0]->big == 3) && !sizeof(g->lines[0]->errors));
]], 1);

test_any([[
  // <qo> should give appropriately sized spaces.

  object g = Monotype.Generator(settings  + (["min_big": 2, "min_little": 5]));
  g->parse("Mary had a little lamb<qo>\n");

  return ((g->lines[0]->little == 5) && (g->lines[0]->big == 2) && !sizeof(g->lines[0]->errors));
]], 1);

test_any([[
  // <qo> should always work.
  object g = Monotype.Generator(settings + (["linelengthp": 30.0]));
  g->parse("Mary had a little lamb<qo>\n");

  return ((g->lines[0]->little == 8) && (g->lines[0]->big == 3) && !sizeof(g->lines[0]->errors));
]], 1);

test_any([[
  // <p> with no justifying space should yield a minimum justification code.
  object g = Monotype.Generator(settings + (["linelengthp": 30.0]));
  g->parse("Mary<p>\n");

  return ((g->lines[0]->little == 8) && (g->lines[0]->big == 3) && !sizeof(g->lines[0]->errors));
]], 1);

test_any([[
  // <p> with at least one space should yield the minimum allowable code per settings.
  object g = Monotype.Generator(settings + (["linelengthp": 30.0]));
  g->parse("Mary had<p>\n");

  return ((g->lines[0]->little == 8) && (g->lines[0]->big == 3) && !sizeof(g->lines[0]->errors));
]], 1);

test_any([[
  // <p> behaves differently from <qo> when within justifying range
  // note the return code of this test.
  object g = Monotype.Generator(settings);
  g->parse("Mary had ");
  g->parse("a little lamb<p>\n");

  return ((g->lines[0]->little == 8) && (g->lines[0]->big == 3) && !sizeof(g->lines[0]->errors));
]], 0);


test_any([[
  // we can make spaces of any size we want.
  object g = Monotype.Generator(settings);
  g->parse("<S32><p>\n");
  return sizeof(g->lines[0]->errors);
 ]], 0);

test_any([[
  // we can make spaces of any size we want, if it's possible given the spaces.
  object g = Monotype.Generator(settings);
  g->parse("<S2><p>\n");
  return sizeof(g->lines[0]->errors);
]], 1);

test_any([[
  // we should be able to use utf8.
  object g = Monotype.Generator(settings);
  g->parse(utf8_to_string("Aâ€™e<p>\n"));
  g->generate_ribbon();
  return sizeof(g->lines[0]->errors);
]], 0);

test_any([[
  // we should get a complaint when a non-available sort is used.
  object g = Monotype.Generator(settings);
  g->parse("A\u2011<p>\n");
  g->generate_ribbon();
  return sizeof(g->lines[0]->errors);
]], 1);

test_any([[
  // we shouldn't drop utf8 sorts.
  object g = Monotype.Generator(settings);
  g->parse("c<p>\n");
  string w = g->generate_ribbon();
  
  object f = Monotype.Generator(settings);
  f->parse("\u2013s<p>\n");
  string x = f->generate_ribbon();
  return w && x && sizeof(x/"\n") == sizeof(w/"\n");
]], 1);

test_any([[
  // this test is obe as overextension of mould is now a warning.
  // test that a hyperextension of mould is flagged.
  object g = Monotype.Generator(settings);
  mixed e = catch {
    g->parse("<l4>W</l4><p>\n");
    g->generate_ribbon();
  };
  return 1;
//  if(e) return 1;
//  else return 0;  
]], 1);

test_any([[
  // test simple tablature:
  object g = Monotype.Generator(settings);
    g->parse("Mary had a little ");
    g->parse("lamb<p>\n");
    g->parse("<center>little lamb<p></center>\n");
    g->parse("Bq dq s<p>\n");
  
    werror("lines: %O\n", g->lines);

    object g1 = Monotype.Generator(settings + (["linelengthp": 40.0]));
    g1->process_setting_buffer(1);
    g1->parse("Foo bar yeah! ");
    g1->process_setting_buffer(1);
    g1->add_column(g->lines[0]);
    g1->low_quad_out(18.0);
    g1->add_column(g->lines[1]);
    g1->low_quad_out(18.0);
    g1->add_column(g->lines[2]);
    g1->new_paragraph();
werror("lines: %O\n", g1->lines[0]->elements);
    
    werror(g1->generate_ribbon());
    return 1;
]], 1);



test_any([[
// need to test simple tablature:
// can add space and arrive at a given unit.
// error when adding space past the requested unit.

// need to test combined spaces

// need to test trip caster
  return 0; 
]], 0);


test_any([[
  // test simple tablature:
  object g = Monotype.Generator(settings + (["min_little": 7, "min_big": 1, "linelengthp": 30.0]));
    string s = Stdio.read_file("CHANGES");
    s = replace(s, "\n", "<p>\n");
    g->parse(s + "<qo>");
//    g->parse("Mary had a little ");
//    g->parse("lamb<p>\n");
    g->parse("<center>little lamb<p></center>\n");
//    g->parse("Bq dq s<p>\n");
  
    werror("lines: %O\n", g->lines);

    int fullpoint = g->lines[0]->lineunits;
    int halfpoint = (int)ceil((float)fullpoint/2);
    float maxf, maxl;
    float minf = (float)fullpoint, minl = (float)fullpoint;
    werror("half point is %O\n", halfpoint);
    foreach(g->lines;;object line)
    {
      object q = Monotype.PositionFinder();
      array x = q->calculate_positions(line);
      float lastpos;
      int broken = 0;
//werror("pos: %O\n", x);
      foreach(x;int x1;float p)
      {
        if(p<=halfpoint + 9) // split the offset (really should be calculated for each MCA) to get equally sized halves.
        {
          lastpos = p;
        }
        else if(!broken)
        {          
          broken = 1;
          float front, back;
          front = lastpos;
          back = fullpoint - lastpos;
          if(lastpos > maxf) maxf = front;
          if(lastpos <= minf) minf = front;
          if((fullpoint - lastpos) > maxl) maxl = (back);
          if((fullpoint - lastpos) <= minl) minl = (back);
          float toaddf, toaddb;
          toaddf = (halfpoint + 14) - front;
          toaddb = (halfpoint + 14) - back;
//          werror("%O/%O: %O on first half, %O on second; adding %O and %O.\n", line->big, line->little, front, back, toaddf, toaddb);

  object f = Monotype.Generator(settings + (["min_little": 7, "min_big": 1, "linelengthp": 0, "lineunits": front]));
  f->make_new_line();  

  int q;
  for(q = 0; q < x1; q++)
  {
    f->current_line->add(line->elements[q]);
//    werror("%O ", line->elements[q]);
  }
//    f->low_quad_out(toaddf); 
  object b = Monotype.Generator(settings + (["min_little": 7, "min_big": 1, "linelengthp": 0, "lineunits": back]));
  b->make_new_line();   

  for(q = x1; q < sizeof(line->elements); q++)
  {
    b->current_line->add(line->elements[q]); 
//    werror("%O ", line->elements[q]);
  }
//  b->low_quad_out(toaddb); 
  object q1 = Monotype.PositionFinder();
  array x1 = q1->calculate_positions(f->current_line);


  object q2 = Monotype.PositionFinder();
  array x2 = q2->calculate_positions(b->current_line);
  string code = sprintf("%O/%O", line->big, line->little);
  string fcode = sprintf("%O/%O", f->current_line->big, f->current_line->little);
  string bcode = sprintf("%O/%O", b->current_line->big, b->current_line->little);
  if(f->current_line->linespaces && fcode != code)
{    werror("%O: %O (%O), %O, (%O)\n", code, fcode, f->current_line->linespaces, bcode, b->current_line->linespaces); 
     werror("%O\n", line->elements);
     werror("%O\n", f->current_line->elements);
     werror("%O\n", b->current_line->elements);
     werror("%O\n", line->linelength);
     werror("%O %O %O %O\n", f->current_line->lineunits, f->current_line->linespaces, f->current_line->linelength, f->current_line->calculate_justification());
     werror("%O %O %O %O\n", b->current_line->lineunits, b->current_line->linespaces, b->current_line->linelength, b->current_line->calculate_justification());
return 0;
}
  else if(b->current_line->linespaces && bcode != code)
    werror("%O: %O (%O), %O, (%O)\n", code, fcode, f->current_line->linespaces, bcode, b->current_line->linespaces);

//werror("front: %O\n", x1);
//werror("back: %O\n", x2);
        }
      }
//      werror("%O/%Opos: %O\n", line->big, line->little, q->calculate_positions(line));
    }
    werror("fullest first half: %O, fullest last half: %O\n", maxf, maxl);
    werror("smallest first half: %O, smallest last half: %O\n", minf, minl);
    werror("first half difference: %O, last half difference: %O\n", maxf-minf, maxl-minl);
    return 0;
]], 0);
