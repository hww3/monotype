<script type="text/javascript">
     dojo.require("dojox.layout.FloatingPane");
     dojo.require("dijit.form.Button");
   dojo.require("dojox.collections.ArrayList");
   dojo.require("dojo.dnd.Source");
   dojo.require("dojo.dnd.Manager");
   dojo.require("dijit.TooltipDialog");
   dojo.require("dijit.form.MatrixEditor");
   var isEditing = false;

function dndDropComplete(s, n, c)
{
  return;
  var mat = s.getItem(n[0].id).data;
//  var manager = dojo.dnd.Manager();
  alert("source: " + s);
  replaceMat(row, col, mat);
}

var micDisplayPane;
var displayPaneSource;
function paneClosed()
{
var div = micDisplayPane.attr("content");
var div2 = dojo.byId("matsInCaseDisplay");
if(div && div2)
{
  div2.innerHTML=displayPaneSource;
micDisplayPane.set("content", "");
init();
}
}

function floatMICDisplay()
{
  var div = dojo.byId("matsInCaseContainer");
  if(div)
  {
  micDisplayPane = new dojox.layout.FloatingPane({
      title: "Available Sorts",
      resizable: false,
      dockable: false,
	  content: div,
	  onclose: function(){alert("close");},
      style: "position:absolute;top:0;left:0;",
      id: "matsInCaseContainer"
  }, dojo.byId("float1"));
//  dijit.byId("micDisplayButton").set("enabled", false);
micDisplayPane.close = function() {

if(!this.closable){ return; } 
 paneClosed();
 this.destroyRecursive();
};
 

  micDisplayPane.startup();
  micDisplayPane.show();
//micDisplayPane.connect(this, "onclose", function(){alert("close");})
  }
}

// based on dojo.dnd.Source.checkAcceptance()
function checkAcceptanceWithoutSelfDrop(source, nodes){
    if(this == source){ return false; }
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var item = source.getItem(nodes[i].id)
                        var type = item.type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
//alert(type[j] + " is acceptable!");
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	}


	// create the DOM representation for the given item
	function micNodeCreator(item, hint) {
		// create a table/tr/td-based node structure; each item here needs an
		// image, a name, a brief description, and a quantity available
		var nameTd = document.createElement("span");
		nameTd.id = "dnd" + item.type + item.character;
		var n;

		if(item.style == "U")
  		  n = (document.createElement("u"));
		else if(item.style == "S")
  		  n = (document.createElement("smallcaps"));
		else if(item.style == "I")
  		  n = (document.createElement("i"));
		else if(item.style == "B")
  		  n = (document.createElement("b"));

		var y = document.createTextNode((" " + item.character) || "N/A");

		if(n)
		{
		   n.appendChild(y);
		}
		else n = y;

		nameTd.appendChild(n);

		dojo.addClass(nameTd, "cell");

		if (hint != "avatar") {
		}else{
			// put the avatar into a self-contained table
			var table = document.createElement("table");
			var tbody = document.createElement("tbody");
			var tr = document.createElement("tr");
			var td = document.createElement("td");
			td.appendChild(nameTd);
			tr.appendChild(td);
			tbody.appendChild(tr);
			table.appendChild(tbody);
			node = table;
		}

		item.id = "dnd" + item.type + item.character;
		
		return {node: nameTd, data: item, id: "dnd" + item.type + item.character, type: item.type};
	};


function processExternalDrop(source, nodes, copy)
{
		// summary: called only on the current target, when drop is performed
		//	from an external source
		// source: Object: the source which provides items
		// nodes: Array: the list of transferred items
		// copy: Boolean: copy items, if true, move items otherwise
		var target = this;
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
/*			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else */ {
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					t.row = this.parent.id;
					t.column = this.parent.id;
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}

		var an = this.getAllNodes();

		dojo.forEach(an, function(n){ 
					replaceMat(n.id, target.getItem(n.id), source.getItem(nodes[0].id)); 
					target.delItem(n.id); n.parentNode.removeChild(n); });

		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
}

function saveMat(wgt)
{
//alert("saveMat");
  isEditing = false;
  dojo.xhrPost({ widget: wgt, content: {matrix: wgt.getValue()}, url: "/mca/setMat?col=" + wgt.column + "&row=" + wgt.row + "&xmatrix=" + wgt.getValue(),
					load: function(response, ioArgs){wgt.setNewVal();} 
	});
}

function replaceMat(pos, data, newmat)
{
  isEditing = false;
  dojo.xhrPost({ url: "/mca/replaceMat?pos=" + pos + "&matrix=" + dojo.toJson(newmat),
					load: function(response, ioArgs){} 
	});
}

function cancelMat(wgt)
{
  isEditing = false;
//  wgt.close();
}



function openWidget(v, row, col, units)
{
  if(this.isEditing == true) { return; }
  this.isEditing = true;

  // get the mat element, set it to be the contents of the widget div, then create the widget
  dojo.xhrGet({ url: "/mca/getMat?col=" + col + "&row=" + row, handleAs: "xml", load: function(response, ioArgs){ 

    var me = new dijit.TooltipDialog(({id: v.id}));
    var e = new dijit.form.MatrixEditor(({srcId: v.id, row: row, column: col, default_set_width: units, onSave: saveMat, onCancel: cancelMat, mat: response, popup: me}));
    me.set('content', e);
	dijit.popup.open({ popup: me, around: dojo.byId(v.id) });
    dojo.connect(me, "onClose", function(){ isEditing = false; });
  }});
}
</script>

<h1>Layout: <b><%=data->mca->name%></b> &nbsp; Default Wedge: <b><%=data->mca->wedge%></b> &nbsp;</h1>

<%#action_link "action": "cancel"%>
<button href="<%#action_url "action": "cancel"%>">Cancel</button>
</a>
 &nbsp;

<%#action_link "action": "save", "args": data->now%>
	<button href="<%#action_url "action": "save", "args": data->now%>"
<% if(data->is_owner) {
%>
<% } else { %>
disabled="true"
<% } %>
>Save</button>
</a> &nbsp;
<p><div id="float1"></div>
<div id="matsInCaseDisplay">
<div id="matsInCaseContainer">
<div><b>Mats Not In Case</b></div>
<div id="matsInCaseNodeQ" dojoId="matsInCaseNodeQ" xdojoType="dojo.dnd.Source" accept="Q" style="position:relative; float:left" class="container"></div>
<div style="clear: left;">
<div style="position:relative; float:left">Roman: </div>
<div id="matsInCaseNodeR" dojoId="matsInCaseNodeR" xdojoType="dojo.dnd.Source" accept="R" style="position:relative; float:left" class="container"></div>
</div>
<div style="clear: left;">
<div style="position:relative; float:left">Italic: </div>
<div id="matsInCaseNodeI" dojoId="matsInCaseNodeI" xdojoType="dojo.dnd.Source" accept="I" style="position:relative; float:left" class="container"></div>
</div>
<div style="clear: left;">
<div style="position:relative; float:left">Bold: </div>
<div id="matsInCaseNodeB" dojoId="matsInCaseNodeB" xdojoType="dojo.dnd.Source" accept="B" style="position:relative; float:left" class="container"></div>
</div>
<div style="clear: left;">
<div style="position:relative; float:left">Small Caps: </div>
<div id="matsInCaseNodeS" dojoId="matsInCaseNodeS" xdojoType="dojo.dnd.Source" accept="S" style="position:relative; float:left" class="container"></div>
</div>
</div>
</div>
<button dojoType="dijit.form.Button" dojoId="micDisplayButton" id="micDisplayButton" onclick="floatMICDisplay">Float</button>
<p>
	<style>
	div.cell {
		font-size: 13pt; width:35px; height:35px; 
border-width:1px; border-style: solid; position:relative; float:left; 
line-height: 15.5px;
	}
	input.mine { border-width:1px; border-style: solid; border-color: background-color: #dddddd; }
	</style>

<style type="text/css">
.dijitArrowButton {
  display: block;
}
</style>
<div style="clear: left;">
<div class="cell"><font style="color:grey"><%=data->wedge->name%></font></div>
<%foreach(data->cols; int k; string v){%>
<div class="cell"><b><%=v%></b></div>
<%}%>
<div class="cell"><font style="color:grey"><%=data->wedge->name%></font></div>
</div>

<%
  foreach(data->rows; int k; int v){
	int u = data->wedge->bars[v];
%>
<div style="clear: left">
	<!-- the first div is the row number with the unit width for that row from the default wedge -->
<div class="cell"
><b><%=v%></b><br/><font style="color: grey"><%=u%>U</font></div>
<%
  foreach(data->cols;int ck; string cv){
		mapping row = data->mca->matcase[cv];
		string ch = "";
		string st = "";
		if(row) 
		{
			object mat = row[v];
			if(mat) 
			{ 
			  ch = mat->character;

			  if(u != (int)mat->set_width) 
   			    st = "style=\"background: yellow\"";

			  if(mat->is_js)
		  	    ch = "<img src=\"/static/images/js.png\">";
			  else if(mat->is_fs)
		  	  	ch = "<img src=\"/static/images/fs.png\">";
			  else
			  {
				switch(mat->style)
				{
					case "B":
						ch = "<b>" + ch + "</b>";
						break;
					case "U":
						ch = "<u>" + ch + "</u>";
						break;
					case "S":
						ch = "<tt>" + ch + "</tt>";
						break;
					case "I":
						ch = "<i>" + ch + "</i>";
						break;
					case "R":
					default:
						break;
				}
			  }
			}
		}
%>

<div class="cell" dojoType="dojo.dnd.Source" dojoId='<%=v + cv%>' id='<%=v + cv%>' <%=st%> accept="R,I,B,S,U" onDropExternal="processExternalDrop" onClick="openWidget(this, <%=v%>, '<%=cv%>', <%=u%>)" >
  <div class="dojoDndItem" id='<%=v + cv%>' ><%=ch%></div>
</div>
	<%}%>
</div>

<div class="cell"
><b><%=v%></b><br/><font style="color: grey"><%=u%>U</font></div>

	<p/>
<%}	%>
<p>
<div style="clear: left;">

<% if( data && data->problems && sizeof(data->problems) ) { %>
<b>Problems:</b>
<br>

<% foreach(data->problems; int i; array p) { %>
 <%=(((int)i)+1)%> <%=p[2]%><br>
<% } %>

<% } else {%>
<b>No problems identified.</b>
<% } %>
</div>
<script type="text/javascript">
	function init() {
	var wishlist, mic, connected;
	
	displayPaneSource = dojo.byId("matsInCaseDisplay").innerHTML;
<% foreach(data->not_in_matcase;string style; array elems) { 
%>
		wishlist = new dojo.dnd.Source("matsInCaseNode<%=style%>"
		,
			{isSource:true, copyOnly: true, 
                          creator: micNodeCreator, accept: ["<%=style%>"]}

);
		wishlist.checkAcceptance = checkAcceptanceWithoutSelfDrop;

		// we only need to connect the first one; the others will get it automatically.
		if(!connected)
                {
  		  dojo.connect(wishlist, "onDndDrop", dndDropComplete);
                  connected = 1;
                }

wishlist.insertNodes(false, [
<%
     foreach(elems;; string mat)
     {
%>
  <%= Tools.JSON.serialize((["data": mat, "character": mat, "style": style, "id": "dnd" + style + mat, "type": ({style}) ])) %>,
<%
     }
%>
]);
<%
   } 
%>

  };
	dojo.addOnLoad(init);
</script>

<div style="left:5px; clear:left">
<%#action_link "action": "cancel"%>
<button href="<%#action_url "action": "cancel"%>">Cancel</button>
</a>		
<%#action_link "action": "save", "args": data->now%>
	<button href="<%#action_url "action": "save", "args": data->now%>"
<% if(data->is_owner) {
%>
<% } else { %>
disabled="true"
<% } %>
>Save</button>
</a> &nbsp;

</div>
</div>
